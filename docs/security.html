<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" href="Images/sword.png" type="image/sword-icon">
    <script src="Scripts/script.js"></script>
    <link rel="stylesheet" href="project-style.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Poppins:wght@600;800&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sour Security | Game Project</title>
</head>
<body id="body">
    
    <!-- Header Section -->
    <header class="header">
        <a href="index.html" class="back-button">
            <img src="Images/chevron_left_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg" alt="Back"> Go Back
        </a>
        <div class="header-container">
            <h1 class="site-title">Sour Security</h1>
            <div class="nav-container">
                <nav class="nav-links">
                    <a href="index.html">Home</a>
                    <a href="https://github.com/Yizune/Sour-Security" target="_blank">GitHub</a>
                    <a href="CV/UpdatedCV.pdf" target="_blank">Resume</a>
                    <a href="https://www.linkedin.com/in/stevan-likusic-884946300/" target="_blank">LinkedIn</a>
                    <a href="https://futuregames.itch.io/sour-security" target="_blank">Itch.io</a>
                </nav>
                <button id="mode-toggle" class="mode-button" onclick="toggleMode()">
                    <img id="mode-icon" src="Images/DarkMode.svg" alt="Dark Mode">
                </button>
            </div>
        </div>
    </header>

    <!-- Welcome Section -->
    <section id="welcome" class="welcome">
        <div class="welcome-divider">
            <div class="line"></div>
            <img src="Images/sword.png" alt="Sword Icon" class="sword-icon">
            <div class="line"></div>
        </div>
        <h2>Sour Security</h2>
        <p>A twisted puzzle sandbox where office objects are your greatest weapon.</p>
    </section>

    <!-- Main Content -->
    <div class="container">

        <!-- Project Banner -->
        <div class="project-banner">
            <div class="project-image">
                <img src="Images/SourSecurity.png" alt="Project Asylum">

                <div class="project-title">
                    <span class="title">Sour Security</span>
                    <div class="overlay-icons">
                        <a href="https://github.com/Yizune/Sour-Security" target="_blank">
                            <img src="Images/github-142-svgrepo-com.svg" alt="GitHub">
                        </a>
                        <a href="CV/UpdatedCV.pdf" target="_blank">
                            <img src="Images/resume.svg" alt="Resume">
                        </a>
                        <a href="https://www.linkedin.com/in/stevan-likusic-884946300/" target="_blank">
                            <img src="Images/linkedin-circle-svgrepo-com.svg" alt="LinkedIn">
                        </a>
                        <a href="https://matthew-gd23.itch.io/project-asylum" target="_blank">
                            <img src="Images/itch-io-svgrepo-com.svg" alt="Itch.io">
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- Project Information -->
        <section class="project-info">
            <div class="info-box">
                <h3>About</h3>
                <p>
                    <strong>Sour Security</strong> is a <strong>dark-humoured puzzle sandbox game</strong> that puts you in the shoes of Merton, 
                    a paranoid security guard in an office filled with supposed threats. Instead of maintaining order, 
                    Merton wreaks havoc, using office equipment to sabotage coworkers and create chaos. From robot vacuums 
                    to printers, every object becomes a tool for player to use against the twisted company that betrayed him.
                </p>
            </div>
            <div class="info-box">
                <h3>Project Details</h3>
                <ul>
                    <li><img src="Images/person_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg" alt="Role Icon"> <strong>My Role:</strong> Gameplay Systems Programmer (Interaction Systems, Object Mechanics, Prototyping)</li>
                    <li><img src="Images/group.svg" alt="Team Icon"> <strong>Team Size:</strong> 7</li>
                    <li><img src="Images/tool.svg" alt="Engine Icon"> <strong>Engine:</strong> Unreal Engine 5 (C++ & Blueprints)</li>
                    <li><img src="Images/time.svg" alt="Time Icon"> <strong>Development Time:</strong> 4 weeks</li>
                </ul>
            </div>
        </section>

        <!-- Project Description -->
        <section class="project-description">
            <h2>Sour Security</h2>
            
            <h3>Introduction</h3>
            <p>
                In <strong>Sour Security</strong>, you play as Merton, a security guard whose growing paranoia turns 
                everyday office life into a battleground of sabotage and mischief. The more Merton tampers with the office 
                environment, the more hostile and unpredictable it becomes. Will you outwit your coworkers, or will the chaos 
                spiral beyond your control?
            </p>
        
            <h3>Gameplay and Features</h3>
            <ul>
                <li><strong>Environmental Manipulation:</strong> Use office tools like vending machines, robot vacuums, and printers to sabotage unsuspecting coworkers.</li>
                <li><strong>AI Reactions:</strong> Dynamic AI behaviors that react to distractions and traps, adding layers of unpredictability to the gameplay.</li>
                <li><strong>Puzzle-Based Challenges:</strong> Strategize how to chain events for maximum chaos while keeping Merton's anxiety in check.</li>
                <li><strong>Dark Humour & Twisted Mechanics:</strong> A quirky mix of comedy and sabotage in an office setting.</li>
            </ul>
        
            <h3>Development Process, My Contributions & Lessons Learned</h3>
            <p>
                As a gameplay programmer, I focused on building robust interaction systems and AI mechanics that brought 
                the chaotic vision of <strong>Sour Security</strong> to life. Here are the key areas I contributed to:
            </p>
        
            <ul>
                <li><strong>AI Interaction Systems:</strong> Developed distraction mechanics where AI characters react to sabotaged objects, 
                creating dynamic puzzle opportunities.</li>
        
                <li><strong>Object Mechanics:</strong> Programmed interactive office equipment like printers and vending machines 
                to respond to player actions in humorous and unexpected ways.</li>
        
                <li><strong>Prototyping and Iteration:</strong> Spent a lot of time experimenting with different ideas and mechanics, building 
                    quick prototypes to test what worked and what didn't. Not everything made it into the final game, but each iteration taught 
                    me something new and helped shape better solutions.</li>

                <li><strong>Background pressence:</strong> Spent some time in the final days of the project creating some movement in the background,
                making it feel like the office truly was in a city-like environment with all the pedestrians and cars moving around. A very challenging
                thing was handling animations due to the fact that I had to hard code a lot of things, simply because some animations did not exist
                for the assets we were using, and I was naturally not great dealing with animations as I barely done them before, so I didn't have the 
                easiest time, but I managed to pull through in the end!</li>
            </ul>
        
            <p>
                Working on <strong>Sour Security</strong> really helped me level up my skills in C++ and Unreal Blueprints, 
                especially when it came to event-driven programming and building complex interaction systems. It pushed my 
                problem-solving abilities as I tackled all kinds of challenges integrating different mechanics. Even though a lot of 
                my work ended up being changed, scrapped, or used as temporary fixes, I don't regret a second of it. It was all part of the process, 
                and it helped me grow a lot as a programmer and a person, and come to realization of my own limits.
            </p>
        
            <p>
                <strong>Download the files below</strong> to explore my personal contributions during the development of <strong>Sour Security</strong>.
            </p>
        
            <div class="download-container">
                <a href="Files/FG23GP, Group Project 4.zip" class="download-button" download>
                    Download Personal Contributions
                </a>
            </div>

            <!-- Code Section -->
            <section class="project-code">
                <h3>Code</h3>
                <p>View key scripts and blueprints I worked on in Sour Security.</p>
        
                <!-- Toggle Buttons -->
                <div class="code-buttons">
                    <button class="code-toggle" data-target="componentInheritor">Component Inheritor</button>
                    <button class="code-toggle" data-target="robotParent">Robot Parent</button>
                    <button class="code-toggle" data-target="interactComponent">InteractComponent.cpp</button>
                    <button class="code-toggle" data-target="interactableComponent">InteractableComponent.cpp</button>
                    <button class="code-toggle" data-target="interactableTarget">InteractableTarget.cpp</button>
                    <button class="code-toggle" data-target="distractableComponent">DistractableComponent.cpp</button>
                    <button class="code-toggle" data-target="interactableParent">Interactable_Distractable_Parent.cpp</button>
                    <button class="code-toggle" data-target="overloadComponent">OverloadComponent.cpp</button>
                    <button class="code-toggle" data-target="boobytrapComponent">BoobytrapComponent.cpp</button>
                    <button class="code-toggle" data-target="bucket">Bucket Object</button>
                    <button class="code-toggle" data-target="door">Door Object</button>
                    <button class="code-toggle" data-target="trashcan">Trashcan Object</button>
                    <button class="code-toggle" data-target="pedestrianSpawner">PedestrianSpawner.cpp</button>
                    <button class="code-toggle" data-target="carSpawner">CarSpawner.cpp</button>
                </div>


            
                <div class="code-container">

                    <div id="robotParent" class="code-snippet">
                        <p><strong>Robot Parent Object:</strong> A base AI Blueprint for robot enemies, managing movement, detection, attacks, and animations. It handles state transitions, damage, and destruction, making it a flexible parent for enemy variations.</p>
                        <p><strong>NOTE: </strong>Due to possible issues in rendering, in case you can not see the lines connecting the nodes, simply try moving the nodes and the lines will appear.</p>
                        <iframe src="https://blueprintue.com/render/68hlzw92/" width="1000" height="400" scrolling="no" allowfullscreen></iframe>
                        <!-- <img src="Code-Images/Robot Parent Object.png" alt="Blueprint"> -->
                    </div>

                    <div id="componentInheritor" class="code-snippet">
                        <p><strong>Component Inheritor (Child Actor Blueprint):</strong> This Blueprint demonstrates how key interaction events are inherited from a parent component to a child actor. It handles events like OnInteractionStarted, OnInteractionFinished, OnOverloadStarted, and OnOverloadFinished, enabling modular and reusable interaction logic across different objects in the game.</p>
                        <p><strong>NOTE: </strong>Due to possible issues in rendering, in case you can not see the lines connecting the nodes, simply try moving the nodes and the lines will appear.</p>
                        <!-- <img src="Code-Images/Component Inheritor (Child Actor Blueprint).png" alt="Component Inheritor Blueprint"> -->
                        <iframe src="https://blueprintue.com/render/ghnqlxme/" width="1000" height="400" scrolling="no" allowfullscreen></iframe>
                    </div>

                    <div id="bucket" class="code-snippet">
                        <p><strong>Bucket Object: </strong>Handles physics interactions on hit, adjusting position and rotation. Uses a line trace to detect surfaces for puddle spawning.</p>
                        <p><strong>NOTE: </strong>Due to possible issues in rendering, in case you can not see the lines connecting the nodes, simply try moving the nodes and the lines will appear.</p>
                        <iframe src="https://blueprintue.com/render/2jcksduh/" width="1000" height="400" scrolling="no" allowfullscreen></iframe>
                    </div>

                    <div id="door" class="code-snippet">
                        <p><strong>Door Object: </strong>This blueprint controls door interactions, handling opening, closing, and locking with animations and sounds. It responds to player proximity and conditions. It deals with enemies by slamming them if they collide during opening/closing of the door. If it hits an enemy, it will knock it out.</p>
                        <p><strong>NOTE: </strong>Due to possible issues in rendering, in case you can not see the lines connecting the nodes, simply try moving the nodes and the lines will appear.</p>
                        <iframe src="https://blueprintue.com/render/n-pi9ne7/" width="1000" height="400" scrolling="no" allowfullscreen></iframe>
                    </div>

                    <div id="trashcan" class="code-snippet">
                        <p><strong>Trashcan Object: </strong>These Blueprints handle the mechanics of a bucket tipping over when hit. When the bucket is struck, it spills trash by spawning an actor, simulating a realistic interaction.</p>
                        <p><strong>NOTE: </strong>Due to possible issues in rendering, in case you can not see the lines connecting the nodes, simply try moving the nodes and the lines will appear.</p>
                        <iframe src="https://blueprintue.com/render/jk9nltc-/" width="1000" height="400" scrolling="no" allowfullscreen></iframe>
                    </div>

                    <pre id="boobytrapComponent" class="code-snippet">
                        <code>
                        // BoobytrapComponent.cpp
                        #include "BoobytrapComponent.h"
                        #include "OverloadComponent.h"
                        #include "TimerManager.h"
                        
                        UBoobytrapComponent::UBoobytrapComponent()
                        {
                            PrimaryComponentTick.bCanEverTick = true;
                            BoobytrapState = E_BoobytrapState::NotBoobytrapped;
                        }
                        
                        void UBoobytrapComponent::BeginPlay()
                        {
                            Super::BeginPlay();
                        
                            AActor* Owner = GetOwner();
                            if (Owner)
                            {
                                OverloadComponent = Owner->FindComponentByClass<UOverloadComponent>();
                            }
                        }
                        
                        void UBoobytrapComponent::SetBoobytrap()
                        {
                            if (BoobytrapState == E_BoobytrapState::NotBoobytrapped && OverloadComponent)
                            {
                                BoobytrapState = E_BoobytrapState::Boobytrapped;
                                UE_LOG(LogTemp, Warning, TEXT("Boobytrap set! Waiting for enemy to trigger..."));
                                
                                OnBoobytrapStarted.Broadcast();
                            }
                        }
                        
                        void UBoobytrapComponent::TriggerBoobytrap()
                        {
                            if (BoobytrapState == E_BoobytrapState::Boobytrapped && OverloadComponent)
                            {
                                UE_LOG(LogTemp, Warning, TEXT("Boobytrap triggered! Starting overload..."));
                        
                                OverloadComponent->StateOverload();  
                            }
                        }
                        
                        void UBoobytrapComponent::EndBoobytrap()
                        {
                            BoobytrapState = E_BoobytrapState::NotBoobytrapped;
                            OnBoobytrapFinished.Broadcast();
                            UE_LOG(LogTemp, Warning, TEXT("Boobytrap deactivated!"));
                        }
                        </code>
                    </pre>
                        
            
                    <pre id="overloadComponent" class="code-snippet">
                        <code>
                        // OverloadComponent.cpp
                        #include "OverloadComponent.h"
                        #include "BoobytrapComponent.h"
                        #include "Components/SphereComponent.h"
                        #include "GameFramework/Actor.h"
                        #include "TimerManager.h"
                        
                        UOverloadComponent::UOverloadComponent()
                        {
                            PrimaryComponentTick.bCanEverTick = true;
                        
                            SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
                            SphereComponent->SetHiddenInGame(false);
                            SphereComponent->SetSphereRadius(300.0f);
                            SphereComponent->SetCollisionProfileName(TEXT("OverlapAllDynamic"));
                        
                            SphereComponent->OnComponentBeginOverlap.AddDynamic(this, &UOverloadComponent::OnComponentBeginOverlap);
                            SphereComponent->OnComponentEndOverlap.AddDynamic(this, &UOverloadComponent::OnComponentEndOverlap);
                        
                            OverloadState = E_OverloadState::NotOverloaded;
                            OverloadDuration = 10.0f;
                            CurrentCountdownTime = 0.0f;
                        }
                        
                        void UOverloadComponent::BeginPlay()
                        {
                            Super::BeginPlay();
                            
                            AActor* Owner = GetOwner();
                            if (Owner)
                            {
                                BoobytrapComponent = Owner->FindComponentByClass<UBoobytrapComponent>();
                                if (BoobytrapComponent)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("BoobytrapComponent found and assigned."));
                                }
                                else
                                {
                                    UE_LOG(LogTemp, Error, TEXT("BoobytrapComponent not found!"));
                                }
                            }
                        }
                        
                        void UOverloadComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                        {
                            Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                        }
                        
                        void UOverloadComponent::StateOverload()
                        {
                            if (OverloadState == E_OverloadState::NotOverloaded)
                            {
                                OverloadState = E_OverloadState::Overloaded;
                                OnOverloadStarted.Broadcast();
                                CurrentCountdownTime = OverloadDuration;
                                
                                GetWorld()->GetTimerManager().SetTimer(CountdownTimerHandle, this, &UOverloadComponent::UpdateCountdown, 1.0f, true);
                                UE_LOG(LogTemp, Warning, TEXT("Overload started"));
                            }
                        }
                        
                        void UOverloadComponent::UpdateCountdown()
                        {
                            if (CurrentCountdownTime > 0)
                            {
                                CurrentCountdownTime--;
                        
                                if (GEngine)
                                {
                                    GEngine->AddOnScreenDebugMessage(1, 1.0f, FColor::Yellow, FString::Printf(TEXT("Overload Time Remaining: %.0f seconds"), CurrentCountdownTime));
                                }
                            }
                            else
                            {
                                EndOverload();
                            }
                        }
                        
                        void UOverloadComponent::EndOverload()
                        {
                            GetWorld()->GetTimerManager().ClearTimer(CountdownTimerHandle);
                            OnOverloadFinished.Broadcast();
                            OverloadState = E_OverloadState::NotOverloaded;
                            UE_LOG(LogTemp, Warning, TEXT("Overload finished"));
                            
                            if (BoobytrapComponent && BoobytrapComponent->GetBoobytrapState() == E_BoobytrapState::Boobytrapped)
                            {
                                BoobytrapComponent->EndBoobytrap(); 
                            }
                        }
                        
                        void UOverloadComponent::OnComponentBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
                        {
                            UE_LOG(LogTemp, Warning, TEXT("Overlap detected with %s"), *OtherActor->GetName());
                        
                            if (BoobytrapComponent && BoobytrapComponent->GetBoobytrapState() == E_BoobytrapState::Boobytrapped)
                            {
                                UE_LOG(LogTemp, Warning, TEXT("Enemy entered boobytrapped zone!"));
                                BoobytrapComponent->TriggerBoobytrap(); 
                            }
                        
                            if (OverloadState == E_OverloadState::Overloaded && OtherActor && OtherActor != GetOwner())
                            {
                                if (OtherActor->ActorHasTag(TEXT("Enemy")))
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Enemy entered Overload zone! Destroying enemy!"));
                                    OtherActor->Destroy();
                                }
                            }
                        }
                        
                        void UOverloadComponent::OnComponentEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
                        {

                        }
                        </code>
                    </pre>


                    <pre id="carSpawner" class="code-snippet">
                        <code>
                        // CarSpawner.cpp - lots of hardcoded stuff because we didn't have animations and i lacked expirience in that field
                        #include "CarSpawner.h"
                        #include "Kismet/GameplayStatics.h"
                        #include "Animation/AnimBlueprint.h"
                        #include "Components/SkeletalMeshComponent.h"
                        #include "UObject/UObjectIterator.h"
                        #include "Engine/World.h"
                        #include "TimerManager.h"
                        
                        ACarSpawner::ACarSpawner()
                        {
                            PrimaryActorTick.bCanEverTick = true;
                        }
                        
                        void ACarSpawner::BeginPlay()
                        {
                            Super::BeginPlay();
                            
                            TArray<AActor*> CarSpawnPointActors;
                            UGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), CarSpawnPointActors);
                        
                            for (AActor* Actor : CarSpawnPointActors)
                            {
                                if (Actor->GetName().Contains("CarSpawnPoint"))
                                {
                                    CarSpawnPoints.Add(Actor);
                                    SetNextCarSpawnTimer(Actor);
                                }
                            }
                        }
                        
                        void ACarSpawner::Tick(float DeltaTime)
                        {
                            Super::Tick(DeltaTime);
                        
                            for (int32 i = SpawnedCars.Num() - 1; i >= 0; i--)
                            {
                                AActor* Car = SpawnedCars[i];
                                if (Car)
                                {
                                    FVector ForwardVector = Car->GetActorForwardVector();
                                    FVector NewLocation = Car->GetActorLocation() + (ForwardVector * CarSpeed * DeltaTime);
                                    Car->SetActorLocation(NewLocation);
                                    
                                    if (NewLocation.X > 10000.0f || NewLocation.X < -10000.0f || NewLocation.Y > 10000.0f || NewLocation.Y < -10000.0f)
                                    {
                                        Car->Destroy();
                                        SpawnedCars.RemoveAt(i);
                                    }
                                }
                            }
                        }
                        
                        void ACarSpawner::SetNextCarSpawnTimer(AActor* SpawnPoint)
                        {
                            float RandomCooldown = FMath::RandRange(10.0f, 15.0f);
                            FTimerHandle NewTimer;
                            GetWorld()->GetTimerManager().SetTimer(NewTimer, [this, SpawnPoint]() { SpawnRandomCar(SpawnPoint); }, RandomCooldown, false);
                            CarSpawnTimers.Add(NewTimer);
                        }
                        
                        void ACarSpawner::SpawnRandomCar(AActor* SpawnPoint)
                        {
                            if (CarMeshes.Num() > 0 && CarMaterials.Num() > 0)
                            {
                                int32 RandomMeshIndex = FMath::RandRange(0, CarMeshes.Num() - 1);
                                int32 RandomMaterialIndex = FMath::RandRange(0, CarMaterials.Num() - 1);
                                FVector SpawnLocation = SpawnPoint->GetActorLocation();
                                FRotator SpawnRotation = SpawnPoint->GetActorRotation();
                        
                                FTransform SpawnTransform(SpawnRotation, SpawnLocation);
                                AActor* SpawnedCar = GetWorld()->SpawnActor<AActor>(AActor::StaticClass(), SpawnTransform);
                        
                                if (SpawnedCar)
                                {
                                    USkeletalMeshComponent* CarMeshComponent = NewObject<USkeletalMeshComponent>(SpawnedCar);
                                    CarMeshComponent->RegisterComponentWithWorld(GetWorld());
                                    CarMeshComponent->SetSkeletalMesh(CarMeshes[RandomMeshIndex]);
                                    CarMeshComponent->SetMaterial(0, CarMaterials[RandomMaterialIndex]);
                                    SpawnedCar->SetRootComponent(CarMeshComponent);
                                    SpawnedCar->SetActorTransform(SpawnTransform);
                        
                                    UAnimBlueprint* SelectedAnimBlueprint = nullptr;
                                    switch (RandomMeshIndex)
                                    {
                                        case 0:
                                            SelectedAnimBlueprint = Cast<UAnimBlueprint>(StaticLoadObject(UAnimBlueprint::StaticClass(), nullptr, TEXT("/Game/Developers/stevanlikusic/CarWheelRotation1.CarWheelRotation1")));
                                            break;
                                        case 1:
                                            SelectedAnimBlueprint = Cast<UAnimBlueprint>(StaticLoadObject(UAnimBlueprint::StaticClass(), nullptr, TEXT("/Game/Developers/stevanlikusic/CarWheelRotation2.CarWheelRotation2")));
                                            break;
                                        case 2:
                                            SelectedAnimBlueprint = Cast<UAnimBlueprint>(StaticLoadObject(UAnimBlueprint::StaticClass(), nullptr, TEXT("/Game/Developers/stevanlikusic/CarWheelRotation3.CarWheelRotation3")));
                                            break;
                                        case 3:
                                            SelectedAnimBlueprint = Cast<UAnimBlueprint>(StaticLoadObject(UAnimBlueprint::StaticClass(), nullptr, TEXT("/Game/Developers/stevanlikusic/CarWheelRotation4.CarWheelRotation4")));
                                            break;
                                        case 4:
                                            SelectedAnimBlueprint = Cast<UAnimBlueprint>(StaticLoadObject(UAnimBlueprint::StaticClass(), nullptr, TEXT("/Game/Developers/stevanlikusic/CarWheelRotation5.CarWheelRotation5")));
                                            break;
                                        default:
                                            UE_LOG(LogTemp, Error, TEXT("Invalid RandomMeshIndex for car"));
                                            break;
                                    }
                        
                                    if (SelectedAnimBlueprint)
                                    {
                                        CarMeshComponent->SetAnimInstanceClass(SelectedAnimBlueprint->GeneratedClass);
                                        UE_LOG(LogTemp, Warning, TEXT("Assigned Animation Blueprint: %s to the car"), *SelectedAnimBlueprint->GetName());
                                        
                                        UAnimInstance* AnimInstance = CarMeshComponent->GetAnimInstance();
                                        if (AnimInstance)
                                        {
                                            CarMeshComponent->Play(true);  
                                            UE_LOG(LogTemp, Warning, TEXT("Animation is forced to play."));
                                        }
                                        else
                                        {
                                            UE_LOG(LogTemp, Error, TEXT("AnimInstance is NULL. Animation not applied."));
                                        }
                                    }
                                    else
                                    {
                                        UE_LOG(LogTemp, Error, TEXT("Failed to assign animation blueprint to the car."));
                                    }
                        
                                    SpawnedCars.Add(SpawnedCar);
                                }
                            }
                            SetNextCarSpawnTimer(SpawnPoint);
                        }
                        </code>
                        </pre>
                        

                        <pre id="distractableComponent" class="code-snippet">
                            <code>
                            // DistractableComponent.cpp
                            #include "DistractableComponent.h"
                            #include "Components/SphereComponent.h"
                            #include "GameFramework/Actor.h"
                            
                            UDistractableComponent::UDistractableComponent()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                            
                                SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
                                SphereComponent->SetHiddenInGame(false);
                                SphereComponent->SetSphereRadius(300.0f);
                                SphereComponent->SetCollisionProfileName(TEXT("OverlapAllDynamic"));
                            
                                SphereComponent->OnComponentBeginOverlap.AddDynamic(this, &UDistractableComponent::OnComponentBeginOverlap);
                                SphereComponent->OnComponentEndOverlap.AddDynamic(this, &UDistractableComponent::OnComponentEndOverlap);
                            
                                RootComponent = SphereComponent;
                            }
                            
                            void UDistractableComponent::BeginPlay()
                            {
                                Super::BeginPlay();
                            }
                            
                            void UDistractableComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                            {
                                Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                            }
                            
                            void UDistractableComponent::OnComponentBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
                            {
                                if (OtherActor != nullptr && OtherActor != GetOwner())
                                {
                                    if (OtherActor->ActorHasTag(TEXT("Enemy")))
                                    {
                                        // Uncomment if debug info is needed
                                        // UE_LOG(LogTemp, Warning, TEXT("Started overlapping with the actor that has the 'Enemy' tag!"));
                                    }
                                }
                                OnDistractionStarted.Broadcast();
                            }
                            
                            void UDistractableComponent::OnComponentEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
                            {
                                if (OtherActor != nullptr && OtherActor != GetOwner())
                                {
                                    if (OtherActor->ActorHasTag(TEXT("Enemy")))
                                    {
                                        // Uncomment if debug info is needed
                                        // UE_LOG(LogTemp, Warning, TEXT("Ended overlapping with the actor that has the 'Enemy' tag!"));
                                    }
                                }
                                OnDistractionFinished.Broadcast();
                            }
                            </code>
                        </pre>
                            

                        <pre id="interactableParent" class="code-snippet">
                            <code>
                            // Interactable_Distractable_Parent.cpp
                            #include "Interactable_Distractable_Parent.h"
                            #include "InteractableComponent.h"
                            #include "OverloadComponent.h"
                            #include "BoobytrapComponent.h"
                            
                            AInteractable_Distractable_Parent::AInteractable_Distractable_Parent()
                            {
                                PrimaryActorTick.bCanEverTick = true;
                            
                                InteractableComponent = CreateDefaultSubobject<UInteractableComponent>(TEXT("InteractableComponent"));
                                OverloadComponent = CreateDefaultSubobject<UOverloadComponent>(TEXT("OverloadComponent"));
                                BoobytrapComponent = CreateDefaultSubobject<UBoobytrapComponent>(TEXT("BoobytrapComponent"));
                                InteractableTarget = CreateDefaultSubobject<UInteractableTarget>(TEXT("InteractableTarget"));
                            }
                            
                            void AInteractable_Distractable_Parent::BeginPlay()
                            {
                                Super::BeginPlay();
                            
                                if (InteractableComponent)
                                {
                                    InteractableComponent->SetActive(true);
                                    InteractableComponent->OnInteractionStarted.AddDynamic(this, &AInteractable_Distractable_Parent::OnInteractionStarted_Event);
                                    InteractableComponent->OnInteractionFinished.AddDynamic(this, &AInteractable_Distractable_Parent::OnInteractionFinished_Event);
                                    UE_LOG(LogTemp, Warning, TEXT("InteractableComponent is active"));
                                }
                            
                                if (OverloadComponent)
                                {
                                    OverloadComponent->SetActive(true);
                                    OverloadComponent->OnOverloadStarted.AddDynamic(this, &AInteractable_Distractable_Parent::OnOverloadStarted_Event);
                                    OverloadComponent->OnOverloadFinished.AddDynamic(this, &AInteractable_Distractable_Parent::OnOverloadFinished_Event);
                                    UE_LOG(LogTemp, Warning, TEXT("OverloadComponent is active"));
                                }
                            
                                if (BoobytrapComponent)
                                {
                                    BoobytrapComponent->SetActive(true);
                                    UE_LOG(LogTemp, Warning, TEXT("BoobytrapComponent is active"));
                                }
                            }
                            
                            void AInteractable_Distractable_Parent::Tick(float DeltaTime)
                            {
                                Super::Tick(DeltaTime);
                            }
                            
                            void AInteractable_Distractable_Parent::OnInteractionStarted_Event()
                            {
                                UE_LOG(LogTemp, Display, TEXT("Interaction Started Event"));
                            }
                            
                            void AInteractable_Distractable_Parent::OnInteractionFinished_Event()
                            {
                                UE_LOG(LogTemp, Display, TEXT("Interaction Finished Event"));
                            }
                            
                            void AInteractable_Distractable_Parent::OnOverloadStarted_Event()
                            {
                                UE_LOG(LogTemp, Display, TEXT("Overload Started Event"));
                            }
                            
                            void AInteractable_Distractable_Parent::OnOverloadFinished_Event()
                            {
                                UE_LOG(LogTemp, Display, TEXT("Overload Finished Event"));
                            }
                            </code>
                        </pre>
                        

                        <pre id="interactableComponent" class="code-snippet">
                            <code>
                            // InteractableComponent.cpp
                            #include "InteractableComponent.h"
                            
                            UInteractableComponent::UInteractableComponent()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                                ActivityState = E_ActivityState::Inactive;  
                            }
                            
                            void UInteractableComponent::BeginPlay()
                            {
                                Super::BeginPlay();
                            }
                            
                            void UInteractableComponent::StateInteract()
                            {
                                UE_LOG(LogTemp, Warning, TEXT("Interact() called!"));
                                
                                if (ActivityState == E_ActivityState::Inactive)
                                {
                                    ActivityState = E_ActivityState::Active;
                                    OnInteractionStarted.Broadcast(); 
                                    UE_LOG(LogTemp, Warning, TEXT("Current State: Active")); 
                                }
                                else
                                {
                                    ActivityState = E_ActivityState::Inactive;
                                    OnInteractionFinished.Broadcast(); 
                                    UE_LOG(LogTemp, Warning, TEXT("Current State: Inactive")); 
                                }
                            }
                            
                            void UInteractableComponent::ToggleState()
                            {
                                StateInteract(); 
                            }
                            </code>
                        </pre>


                        <pre id="interactableTarget" class="code-snippet">
                            <code>
                            // InteractableTarget.cpp - This one was very hard coded but it was made for prototyping
                            #include "InteractableTarget.h"
                            #include "GameFramework/PlayerController.h"
                            #include "Engine/Engine.h"
                            #include "InteractableComponent.h"
                            #include "OverloadComponent.h"
                            #include "BoobytrapComponent.h"
                            
                            bool UInteractableTarget::bIsGlobalInteracting = false;
                            
                            UInteractableTarget::UInteractableTarget()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                                bIsInteracting = false;
                            }
                            
                            void UInteractableTarget::BeginPlay()
                            {
                                Super::BeginPlay();
                                
                                bIsGlobalInteracting = false;
                                
                                AActor* Owner = GetOwner();
                                if (Owner)
                                {
                                    InteractableComponent = Owner->FindComponentByClass<UInteractableComponent>();
                                    OverloadComponent = Owner->FindComponentByClass<UOverloadComponent>();
                                    BoobytrapComponent = Owner->FindComponentByClass<UBoobytrapComponent>();
                                }
                            }
                            
                            void UInteractableTarget::EndPlay(const EEndPlayReason::Type EndPlayReason)
                            {
                                Super::EndPlay(EndPlayReason);
                                
                                bIsGlobalInteracting = false;
                            }
                            
                            void UInteractableTarget::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                            {
                                Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                            }
                            
                            void UInteractableTarget::OpenInteractionMenu()
                            {
                                if (bIsGlobalInteracting) 
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("A menu is already open globally. Cannot open another."));
                                    return;
                                }
                            
                                UE_LOG(LogTemp, Warning, TEXT("Menu Options:"));
                            
                                bool bHasOptions = false;
                            
                                if (InteractableComponent && InteractableComponent->IsActive())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("[T] - Interact"));
                                    bHasOptions = true;
                                }
                            
                                if (OverloadComponent && OverloadComponent->IsActive())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("[Y] - Overload"));
                                    bHasOptions = true;
                                }
                            
                                if (BoobytrapComponent && BoobytrapComponent->IsActive())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("[R] - Boobytrap"));
                                    bHasOptions = true;
                                }
                                
                                UE_LOG(LogTemp, Warning, TEXT("[C] - Cancel"));
                            
                                if (!bHasOptions)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("No other actions available, showing only Cancel"));
                                }
                            
                                ClearMenuBindings();
                            
                                APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                if (PC && !bIsInteracting)
                                {
                                    if (InteractableComponent && InteractableComponent->IsActive())
                                    {
                                        PC->InputComponent->BindAction("InteractAction", IE_Pressed, this, &UInteractableTarget::HandleInteractAction);
                                    }
                                    if (OverloadComponent && OverloadComponent->IsActive())
                                    {
                                        PC->InputComponent->BindAction("OverloadAction", IE_Pressed, this, &UInteractableTarget::HandleOverloadAction);
                                    }
                                    if (BoobytrapComponent && BoobytrapComponent->IsActive())
                                    {
                                        PC->InputComponent->BindAction("BoobytrapAction", IE_Pressed, this, &UInteractableTarget::HandleBoobytrapAction);
                                    }
                                    PC->InputComponent->BindAction("CancelAction", IE_Pressed, this, &UInteractableTarget::HandleCancelAction);
                            
                                    bIsInteracting = true;
                                    bIsGlobalInteracting = true; 
                                }
                            }
                            
                            void UInteractableTarget::HandleInteractAction()
                            {
                                if (InteractableComponent)
                                {
                                    InteractableComponent->StateInteract();
                                }
                                ClearMenuBindings(); 
                            }
                            
                            void UInteractableTarget::HandleOverloadAction()
                            {
                                if (OverloadComponent)
                                {
                                    OverloadComponent->StateOverload(); 
                                }
                                ClearMenuBindings();
                            }
                            
                            void UInteractableTarget::HandleBoobytrapAction()
                            {
                                if (BoobytrapComponent)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Boobytrap Activated!"));
                                    BoobytrapComponent->SetBoobytrap();
                                }
                            
                                ClearMenuBindings();
                            }
                            
                            void UInteractableTarget::HandleCancelAction()
                            {
                                UE_LOG(LogTemp, Warning, TEXT("You chose to Cancel"));
                                ClearMenuBindings(); 
                            }
                            
                            void UInteractableTarget::ClearMenuBindings()
                            {
                                APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                if (PC && bIsInteracting)
                                {
                                    PC->InputComponent->RemoveActionBinding("InteractAction", IE_Pressed);
                                    PC->InputComponent->RemoveActionBinding("OverloadAction", IE_Pressed);
                                    PC->InputComponent->RemoveActionBinding("BoobytrapAction", IE_Pressed);
                                    PC->InputComponent->RemoveActionBinding("CancelAction", IE_Pressed);
                            
                                    bIsInteracting = false;
                                    bIsGlobalInteracting = false; 
                                }
                            }
                            </code>
                        </pre>
                            

                        <pre id="interactComponent" class="code-snippet">
                            <code>
                            // InteractComponent.cpp 
                            #include "InteractComponent.h"
                            #include "GameFramework/PlayerController.h"
                            #include "Engine/Engine.h"
                            #include "DrawDebugHelpers.h"
                            #include "GameFramework/Pawn.h"
                            
                            UInteractComponent::UInteractComponent()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                                bCanInteract = true;  
                                CollisionParams.AddIgnoredActor(GetOwner());
                            }
                            
                            void UInteractComponent::BeginPlay()
                            {
                                Super::BeginPlay();
                            
                                OwningPawn = Cast<APawn>(GetOwner());
                                if (OwningPawn && GetWorld())
                                {
                                    APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                    if (PC && PC->InputComponent)
                                    {
                                        PC->InputComponent->BindAction("Interact", IE_Pressed, this, &UInteractComponent::HandleInteract);
                                    }
                                }
                            
                                bCanInteract = OwningPawn->IsValidLowLevel();
                            }
                            
                            void UInteractComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                            {
                                Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                            
                                if (OwningPawn)
                                {
                                    APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                    if (PC)
                                    {
                                        bCanInteract = (PC->GetPawn() == OwningPawn);
                                    }
                                }
                            }
                            
                            void UInteractComponent::InteractableObjectCheck()
                            {
                                if (!bCanInteract)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("bCanInteract is false, returning"));
                                    return;
                                }
                            
                                const AActor* MyActor = GetOwner();
                                if (!MyActor || !GetWorld())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Actor or World not valid"));
                                    return;
                                }
                            
                                FVector ViewForward = MyActor->GetActorForwardVector();
                                FVector ViewStart = MyActor->GetActorLocation();
                                FVector TraceEnd = ViewStart + ViewForward * 1000.0f; 
                            
                                FHitResult HitResult;
                                bool bHit = GetWorld()->LineTraceSingleByChannel(HitResult, ViewStart, TraceEnd, ECC_Visibility, CollisionParams);
                            
                                DrawDebugLine(GetWorld(), ViewStart, TraceEnd, FColor::Green, false, 5.0f, 0.0f, 0.5f);
                            
                                if (bHit)
                                {
                                    AActor* HitActor = HitResult.GetActor();
                                    UE_LOG(LogTemp, Warning, TEXT("Line trace hit %s"), *HitActor->GetName());
                            
                                    InteractableTarget = Cast<UInteractableTarget>(HitActor->GetComponentByClass(UInteractableTarget::StaticClass()));
                                    if (InteractableTarget)
                                    {
                                        UE_LOG(LogTemp, Warning, TEXT("Interactable target found, opening menu"));
                                        InteractableTarget->OpenInteractionMenu();
                                    }
                                }
                                else
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Line trace did not hit any interactable target"));
                                }
                            }
                            
                            void UInteractComponent::HandleInteract()
                            {
                                if (bCanInteract)
                                {
                                    InteractableObjectCheck();
                                }
                            }
                            </code>
                        </pre>

                            
                        <pre id="interactableTarget" class="code-snippet">
                            <code>
                            // InteractableTarget.cpp 
                            #include "InteractableTarget.h"
                            #include "GameFramework/PlayerController.h"
                            #include "Engine/Engine.h"
                            #include "InteractableComponent.h"
                            #include "OverloadComponent.h"
                            #include "BoobytrapComponent.h"
                            
                            bool UInteractableTarget::bIsGlobalInteracting = false;
                            
                            UInteractableTarget::UInteractableTarget()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                                bIsInteracting = false;
                            }
                            
                            void UInteractableTarget::BeginPlay()
                            {
                                Super::BeginPlay();
                                
                                bIsGlobalInteracting = false;
                                
                                AActor* Owner = GetOwner();
                                if (Owner)
                                {
                                    InteractableComponent = Owner->FindComponentByClass<UInteractableComponent>();
                                    OverloadComponent = Owner->FindComponentByClass<UOverloadComponent>();
                                    BoobytrapComponent = Owner->FindComponentByClass<UBoobytrapComponent>();
                                }
                            }
                            
                            void UInteractableTarget::EndPlay(const EEndPlayReason::Type EndPlayReason)
                            {
                                Super::EndPlay(EndPlayReason);
                                
                                bIsGlobalInteracting = false;
                            }
                            
                            void UInteractableTarget::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                            {
                                Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                            }
                            
                            void UInteractableTarget::OpenInteractionMenu()
                            {
                                if (bIsGlobalInteracting) 
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("A menu is already open globally. Cannot open another."));
                                    return;
                                }
                            
                                UE_LOG(LogTemp, Warning, TEXT("Menu Options:"));
                            
                                bool bHasOptions = false;
                            
                                if (InteractableComponent && InteractableComponent->IsActive())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("[T] - Interact"));
                                    bHasOptions = true;
                                }
                            
                                if (OverloadComponent && OverloadComponent->IsActive())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("[Y] - Overload"));
                                    bHasOptions = true;
                                }
                            
                                if (BoobytrapComponent && BoobytrapComponent->IsActive())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("[R] - Boobytrap"));
                                    bHasOptions = true;
                                }
                                
                                UE_LOG(LogTemp, Warning, TEXT("[C] - Cancel"));
                            
                                if (!bHasOptions)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("No other actions available, showing only Cancel"));
                                }
                            
                                ClearMenuBindings();
                            
                                APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                if (PC && !bIsInteracting)
                                {
                                    if (InteractableComponent && InteractableComponent->IsActive())
                                    {
                                        PC->InputComponent->BindAction("InteractAction", IE_Pressed, this, &UInteractableTarget::HandleInteractAction);
                                    }
                                    if (OverloadComponent && OverloadComponent->IsActive())
                                    {
                                        PC->InputComponent->BindAction("OverloadAction", IE_Pressed, this, &UInteractableTarget::HandleOverloadAction);
                                    }
                                    if (BoobytrapComponent && BoobytrapComponent->IsActive())
                                    {
                                        PC->InputComponent->BindAction("BoobytrapAction", IE_Pressed, this, &UInteractableTarget::HandleBoobytrapAction);
                                    }
                                    PC->InputComponent->BindAction("CancelAction", IE_Pressed, this, &UInteractableTarget::HandleCancelAction);
                            
                                    bIsInteracting = true;
                                    bIsGlobalInteracting = true; 
                                }
                            }
                            
                            void UInteractableTarget::HandleInteractAction()
                            {
                                if (InteractableComponent)
                                {
                                    InteractableComponent->StateInteract();
                                }
                                ClearMenuBindings(); 
                            }
                            
                            void UInteractableTarget::HandleOverloadAction()
                            {
                                if (OverloadComponent)
                                {
                                    OverloadComponent->StateOverload(); 
                                }
                                ClearMenuBindings();
                            }
                            
                            void UInteractableTarget::HandleBoobytrapAction()
                            {
                                if (BoobytrapComponent)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Boobytrap Activated!"));
                                    BoobytrapComponent->SetBoobytrap();
                                }
                            
                                ClearMenuBindings();
                            }
                            
                            void UInteractableTarget::HandleCancelAction()
                            {
                                UE_LOG(LogTemp, Warning, TEXT("You chose to Cancel"));
                                ClearMenuBindings(); 
                            }
                            
                            void UInteractableTarget::ClearMenuBindings()
                            {
                                APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                if (PC && bIsInteracting)
                                {
                                    PC->InputComponent->RemoveActionBinding("InteractAction", IE_Pressed);
                                    PC->InputComponent->RemoveActionBinding("OverloadAction", IE_Pressed);
                                    PC->InputComponent->RemoveActionBinding("BoobytrapAction", IE_Pressed);
                                    PC->InputComponent->RemoveActionBinding("CancelAction", IE_Pressed);
                            
                                    bIsInteracting = false;
                                    bIsGlobalInteracting = false; 
                                }
                            }
                            </code>
                        </pre>
                            

                        <pre id="interactComponent" class="code-snippet">
                            <code>
                            // InteractComponent.cpp - 
                            #include "InteractComponent.h"
                            #include "GameFramework/PlayerController.h"
                            #include "Engine/Engine.h"
                            #include "DrawDebugHelpers.h"
                            #include "GameFramework/Pawn.h"
                            
                            UInteractComponent::UInteractComponent()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                                bCanInteract = true;  
                                CollisionParams.AddIgnoredActor(GetOwner());
                            }
                            
                            void UInteractComponent::BeginPlay()
                            {
                                Super::BeginPlay();
                            
                                OwningPawn = Cast<APawn>(GetOwner());
                                if (OwningPawn && GetWorld())
                                {
                                    APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                    if (PC && PC->InputComponent)
                                    {
                                        PC->InputComponent->BindAction("Interact", IE_Pressed, this, &UInteractComponent::HandleInteract);
                                    }
                                }
                            
                                bCanInteract = OwningPawn->IsValidLowLevel();
                            }
                            
                            void UInteractComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                            {
                                Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                            
                                if (OwningPawn)
                                {
                                    APlayerController* PC = GetWorld()->GetFirstPlayerController();
                                    if (PC)
                                    {
                                        bCanInteract = (PC->GetPawn() == OwningPawn);
                                    }
                                }
                            }
                            
                            void UInteractComponent::InteractableObjectCheck()
                            {
                                if (!bCanInteract)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("bCanInteract is false, returning"));
                                    return;
                                }
                            
                                const AActor* MyActor = GetOwner();
                                if (!MyActor || !GetWorld())
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Actor or World not valid"));
                                    return;
                                }
                            
                                FVector ViewForward = MyActor->GetActorForwardVector();
                                FVector ViewStart = MyActor->GetActorLocation();
                                FVector TraceEnd = ViewStart + ViewForward * 1000.0f; 
                            
                                FHitResult HitResult;
                                bool bHit = GetWorld()->LineTraceSingleByChannel(HitResult, ViewStart, TraceEnd, ECC_Visibility, CollisionParams);
                            
                                DrawDebugLine(GetWorld(), ViewStart, TraceEnd, FColor::Green, false, 5.0f, 0.0f, 0.5f);
                            
                                if (bHit)
                                {
                                    AActor* HitActor = HitResult.GetActor();
                                    UE_LOG(LogTemp, Warning, TEXT("Line trace hit %s"), *HitActor->GetName());
                            
                                    InteractableTarget = Cast<UInteractableTarget>(HitActor->GetComponentByClass(UInteractableTarget::StaticClass()));
                                    if (InteractableTarget)
                                    {
                                        UE_LOG(LogTemp, Warning, TEXT("Interactable target found, opening menu"));
                                        InteractableTarget->OpenInteractionMenu();
                                    }
                                }
                                else
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Line trace did not hit any interactable target"));
                                }
                            }
                            
                            void UInteractComponent::HandleInteract()
                            {
                                if (bCanInteract)
                                {
                                    InteractableObjectCheck();
                                }
                            }
                            </code>
                        </pre>
                            

                        <pre id="overloadComponent" class="code-snippet">
                            <code>
                            // OverloadComponent.cpp 
                            #include "OverloadComponent.h"
                            #include "BoobytrapComponent.h"
                            #include "Components/SphereComponent.h"
                            #include "GameFramework/Actor.h"
                            #include "TimerManager.h"
                            
                            UOverloadComponent::UOverloadComponent()
                            {
                                PrimaryComponentTick.bCanEverTick = true;
                            
                                SphereComponent = CreateDefaultSubobject<USphereComponent>(TEXT("SphereComponent"));
                                SphereComponent->SetHiddenInGame(false);
                                SphereComponent->SetSphereRadius(300.0f);
                                SphereComponent->SetCollisionProfileName(TEXT("OverlapAllDynamic"));
                            
                                SphereComponent->OnComponentBeginOverlap.AddDynamic(this, &UOverloadComponent::OnComponentBeginOverlap);
                                SphereComponent->OnComponentEndOverlap.AddDynamic(this, &UOverloadComponent::OnComponentEndOverlap);
                            
                                OverloadState = E_OverloadState::NotOverloaded;
                                OverloadDuration = 10.0f;
                                CurrentCountdownTime = 0.0f;
                            }
                            
                            void UOverloadComponent::BeginPlay()
                            {
                                Super::BeginPlay();
                                
                                AActor* Owner = GetOwner();
                                if (Owner)
                                {
                                    BoobytrapComponent = Owner->FindComponentByClass<UBoobytrapComponent>();
                                    if (BoobytrapComponent)
                                    {
                                        UE_LOG(LogTemp, Warning, TEXT("BoobytrapComponent found and assigned."));
                                    }
                                    else
                                    {
                                        UE_LOG(LogTemp, Error, TEXT("BoobytrapComponent not found!"));
                                    }
                                }
                            }
                            
                            void UOverloadComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
                            {
                                Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
                            }
                            
                            void UOverloadComponent::StateOverload()
                            {
                                if (OverloadState == E_OverloadState::NotOverloaded)
                                {
                                    OverloadState = E_OverloadState::Overloaded;
                                    OnOverloadStarted.Broadcast();
                                    CurrentCountdownTime = OverloadDuration;
                                    
                                    GetWorld()->GetTimerManager().SetTimer(CountdownTimerHandle, this, &UOverloadComponent::UpdateCountdown, 1.0f, true);
                                    UE_LOG(LogTemp, Warning, TEXT("Overload started"));
                                }
                            }
                            
                            void UOverloadComponent::UpdateCountdown()
                            {
                                if (CurrentCountdownTime > 0)
                                {
                                    CurrentCountdownTime--;
                            
                                    if (GEngine)
                                    {
                                        GEngine->AddOnScreenDebugMessage(1, 1.0f, FColor::Yellow, FString::Printf(TEXT("Overload Time Remaining: %.0f seconds"), CurrentCountdownTime));
                                    }
                                }
                                else
                                {
                                    EndOverload();
                                }
                            }
                            
                            void UOverloadComponent::EndOverload()
                            {
                                GetWorld()->GetTimerManager().ClearTimer(CountdownTimerHandle);
                                OnOverloadFinished.Broadcast();
                                OverloadState = E_OverloadState::NotOverloaded;
                                UE_LOG(LogTemp, Warning, TEXT("Overload finished"));
                                
                                if (BoobytrapComponent && BoobytrapComponent->GetBoobytrapState() == E_BoobytrapState::Boobytrapped)
                                {
                                    BoobytrapComponent->EndBoobytrap(); 
                                }
                            }
                            
                            void UOverloadComponent::OnComponentBeginOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
                            {
                                UE_LOG(LogTemp, Warning, TEXT("Overlap detected with %s"), *OtherActor->GetName());
                            
                                if (BoobytrapComponent && BoobytrapComponent->GetBoobytrapState() == E_BoobytrapState::Boobytrapped)
                                {
                                    UE_LOG(LogTemp, Warning, TEXT("Enemy entered boobytrapped zone!"));
                                    BoobytrapComponent->TriggerBoobytrap(); 
                                }
                            
                                if (OverloadState == E_OverloadState::Overloaded && OtherActor && OtherActor != GetOwner())
                                {
                                    if (OtherActor->ActorHasTag(TEXT("Enemy")))
                                    {
                                        UE_LOG(LogTemp, Warning, TEXT("Enemy entered Overload zone! Destroying enemy!"));
                                        OtherActor->Destroy();
                                    }
                                }
                            }
                            
                            void UOverloadComponent::OnComponentEndOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
                            {
                                // No specific behavior for ending overlap
                            }
                            </code>
                        </pre>
                            
                        
                        <pre id="pedestrianSpawner" class="code-snippet">
                            <code>
                            // PedestrianSpawner.cpp - lots of hardcoded stuff because we didn't have animations and i lacked expirience in that field
                            #include "PedestrianSpawner.h"
                            #include "Kismet/GameplayStatics.h"
                            #include "Components/SkeletalMeshComponent.h"
                            #include "Components/SceneComponent.h"
                            #include "Animation/AnimInstance.h"
                            #include "Engine/World.h"
                            
                            APedestrianSpawner::APedestrianSpawner()
                            {
                                PrimaryActorTick.bCanEverTick = true;
                                
                                static ConstructorHelpers::FClassFinder<UAnimInstance> WalkingOnlyBP(TEXT("/Game/Core/AI/Animation/WalkingOnly"));
                                if (WalkingOnlyBP.Succeeded())
                                {
                                    WalkingOnlyAnimBlueprintClass = WalkingOnlyBP.Class;
                                }
                                
                                MinSpawnTime = 10.0f;
                                MaxSpawnTime = 15.0f;
                            }
                            
                            void APedestrianSpawner::BeginPlay()
                            {
                                Super::BeginPlay();
                                UE_LOG(LogTemp, Warning, TEXT("PedestrianSpawner BeginPlay called"));
                                
                                TArray<AActor*> PedestrianSpawnPointActors;
                                UGameplayStatics::GetAllActorsOfClass(GetWorld(), AActor::StaticClass(), PedestrianSpawnPointActors);
                            
                                for (AActor* Actor : PedestrianSpawnPointActors)
                                {
                                    if (Actor->GetName().Contains("PedestrianSpawnPoint"))
                                    {
                                        PedestrianSpawnPoints.Add(Actor);
                                        SetNextPedestrianSpawnTimer(Actor); 
                                    }
                                }
                            
                                UE_LOG(LogTemp, Warning, TEXT("Found %d PedestrianSpawnPoints"), PedestrianSpawnPoints.Num());
                            }
                            
                            void APedestrianSpawner::Tick(float DeltaTime)
                            {
                                Super::Tick(DeltaTime);
                            
                                for (int32 i = SpawnedPedestrians.Num() - 1; i >= 0; i--)
                                {
                                    AActor* Pedestrian = SpawnedPedestrians[i];
                                    if (Pedestrian)
                                    {
                                        USkeletalMeshComponent* PedestrianMeshComponent = Pedestrian->FindComponentByClass<USkeletalMeshComponent>();
                                        if (PedestrianMeshComponent)
                                        {
                                            FVector CurrentLocation = Pedestrian->GetActorLocation();
                                            FVector ForwardVector = Pedestrian->GetActorForwardVector();
                                            FVector NewLocation = CurrentLocation + (ForwardVector * PedestrianSpeed * DeltaTime);
                                            Pedestrian->SetActorLocation(NewLocation);
                            
                                            if (NewLocation.X > 10000.0f || NewLocation.X < -10000.0f || NewLocation.Y > 10000.0f || NewLocation.Y < -10000.0f)
                                            {
                                                Pedestrian->Destroy();
                                                SpawnedPedestrians.RemoveAt(i);
                                            }
                                        }
                                    }
                                }
                            }
                            
                            void APedestrianSpawner::SetNextPedestrianSpawnTimer(AActor* SpawnPoint)
                            {
                                float RandomCooldown = FMath::RandRange(MinSpawnTime, MaxSpawnTime);
                                FTimerHandle NewTimer;
                                GetWorld()->GetTimerManager().SetTimer(NewTimer, [this, SpawnPoint]() { SpawnRandomPedestrian(SpawnPoint); }, RandomCooldown, false);
                                PedestrianSpawnTimers.Add(NewTimer);
                            }
                            
                            void APedestrianSpawner::SpawnRandomPedestrian(AActor* SpawnPoint)
                            {
                                UE_LOG(LogTemp, Warning, TEXT("SpawnRandomPedestrian called"));
                            
                                if (PedestrianMeshes.Num() > 0)
                                {
                                    int32 RandomMeshIndex = FMath::RandRange(0, PedestrianMeshes.Num() - 1);
                                    FVector SpawnLocation = SpawnPoint->GetActorLocation();
                                    FRotator SpawnRotation = SpawnPoint->GetActorRotation();
                            
                                    FTransform SpawnTransform;
                                    SpawnTransform.SetLocation(SpawnLocation);
                                    SpawnTransform.SetRotation(SpawnRotation.Quaternion());
                            
                                    AActor* SpawnedPedestrian = GetWorld()->SpawnActor<AActor>(AActor::StaticClass(), SpawnTransform);
                                    if (SpawnedPedestrian)
                                    {
                                        USceneComponent* RootSceneComponent = NewObject<USceneComponent>(SpawnedPedestrian);
                                        RootSceneComponent->RegisterComponent();
                                        SpawnedPedestrian->SetRootComponent(RootSceneComponent);
                            
                                        USkeletalMeshComponent* PedestrianMeshComponent = NewObject<USkeletalMeshComponent>(SpawnedPedestrian);
                                        if (PedestrianMeshComponent)
                                        {
                                            PedestrianMeshComponent->RegisterComponent();
                                            PedestrianMeshComponent->SetSkeletalMesh(PedestrianMeshes[RandomMeshIndex]);
                                            PedestrianMeshComponent->AttachToComponent(RootSceneComponent, FAttachmentTransformRules::KeepRelativeTransform);
                            
                                            if (WalkingOnlyAnimBlueprintClass)
                                            {
                                                PedestrianMeshComponent->SetAnimInstanceClass(WalkingOnlyAnimBlueprintClass);
                                                PedestrianMeshComponent->SetAnimationMode(EAnimationMode::AnimationBlueprint);
                                            }
                            
                                            FRotator MeshRotation = PedestrianMeshComponent->GetRelativeRotation();
                                            MeshRotation.Yaw += -90.0f;
                                            PedestrianMeshComponent->SetRelativeRotation(MeshRotation);
                            
                                            SpawnedPedestrian->SetActorTransform(SpawnTransform);
                            
                                            UE_LOG(LogTemp, Warning, TEXT("Final Pedestrian Forward Vector: %s"), *SpawnedPedestrian->GetActorForwardVector().ToString());
                            
                                            SpawnedPedestrians.Add(SpawnedPedestrian);
                                        }
                                    }
                                    SetNextPedestrianSpawnTimer(SpawnPoint); 
                                }
                            }
                            </code>
                        </pre>                            
                </div>
                
                <button id="toggleCodeButtons" class="view-all-button" style="display: none;">View All</button>
                
            </section>            
        </section>

        <div class="section-divider"></div>

        <!-- Project Links -->
        <section class="project-links">
            <h3>Explore More</h3>
            <p>Check out the game and my contributions!</p>
            <div class="explore-links">
                <div class="button-row">
                    <a href="https://github.com/Yizune/Sour-Security" target="_blank" class="button">GitHub</a>
                    <a href="https://futuregames.itch.io/sour-security" target="_blank" class="button">Itch.io</a>
                </div>
                <div class="button-row">
                    <a href="https://www.linkedin.com/in/stevan-likusic-884946300/" target="_blank" class="button">LinkedIn</a>
                    <a href="CV/UpdatedCV.pdf" target="_blank" class="button">Resume</a>
                </div>
            </div>
        </section>
    </div>

    <!-- Footer -->
    <footer class="footer">
        <p>&copy; 2025 Stevan Likusic. All Rights Reserved.</p>
    </footer>

</body>
</html>